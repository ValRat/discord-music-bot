"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.CommandContext = void 0;
const constants_1 = require("../../constants");
const user_1 = require("../user");
const collection_1 = __importDefault(require("@discordjs/collection"));
const channel_1 = require("../channel");
const role_1 = require("../role");
const resolvedMember_1 = require("../resolvedMember");
const messageInteraction_1 = require("./messageInteraction");
const message_1 = require("../message");
/** Context representing a command interaction. */
class CommandContext extends messageInteraction_1.MessageInteractionContext {
    /**
     * @param creator The instantiating creator.
     * @param data The interaction data for the context.
     * @param respond The response function for the interaction.
     * @param webserverMode Whether the interaction was from a webserver.
     * @param deferEphemeral Whether the context should auto-defer ephemeral messages.
     */
    constructor(creator, data, respond, webserverMode, deferEphemeral = false) {
        super(creator, data, respond);
        /** The resolved users of the interaction. */
        this.users = new collection_1.default();
        /** The resolved members of the interaction. */
        this.members = new collection_1.default();
        /** The resolved roles of the interaction. */
        this.roles = new collection_1.default();
        /** The resolved channels of the interaction. */
        this.channels = new collection_1.default();
        /** The resolved messages of the interaction. */
        this.messages = new collection_1.default();
        this.data = data;
        this.webserverMode = webserverMode;
        this.commandType = data.data.type;
        this.commandName = data.data.name;
        this.commandID = data.data.id;
        if (data.data.target_id)
            this.targetID = data.data.target_id;
        this.options = data.data.options ? CommandContext.convertOptions(data.data.options) : {};
        this.subcommands = data.data.options ? CommandContext.getSubcommandArray(data.data.options) : [];
        if (data.data.resolved) {
            if (data.data.resolved.users)
                Object.keys(data.data.resolved.users).forEach((id) => this.users.set(id, new user_1.User(data.data.resolved.users[id], this.creator)));
            if (data.data.resolved.members)
                Object.keys(data.data.resolved.members).forEach((id) => this.members.set(id, new resolvedMember_1.ResolvedMember(data.data.resolved.members[id], data.data.resolved.users[id], this.creator)));
            if (data.data.resolved.roles)
                Object.keys(data.data.resolved.roles).forEach((id) => this.roles.set(id, new role_1.Role(data.data.resolved.roles[id])));
            if (data.data.resolved.channels)
                Object.keys(data.data.resolved.channels).forEach((id) => this.channels.set(id, new channel_1.Channel(data.data.resolved.channels[id])));
            if (data.data.resolved.messages)
                Object.keys(data.data.resolved.messages).forEach((id) => this.messages.set(id, new message_1.Message(data.data.resolved.messages[id], this.creator)));
        }
        // Auto-defer if no response was given in 2 seconds
        this._timeout = setTimeout(() => this.defer(deferEphemeral || false), 2000);
    }
    /**
     * The target message of the interaction.
     * Will be `null` if it's not from a message command.
     */
    get targetMessage() {
        if (this.commandType === constants_1.ApplicationCommandType.MESSAGE && this.targetID)
            return this.messages.get(this.targetID);
        else
            return null;
    }
    /**
     * The target user of the interaction.
     * Will be `null` if it's not from a user command.
     */
    get targetUser() {
        if (this.commandType === constants_1.ApplicationCommandType.USER && this.targetID)
            return this.users.get(this.targetID);
        else
            return null;
    }
    /**
     * The target member of the interaction.
     * Will be `null` if it's not from a user command.
     */
    get targetMember() {
        if (this.commandType === constants_1.ApplicationCommandType.USER && this.targetID)
            return this.members.get(this.targetID);
        else
            return null;
    }
    /** @private */
    static convertOptions(options) {
        const convertedOptions = {};
        for (const option of options) {
            if ('options' in option)
                convertedOptions[option.name] = option.options ? CommandContext.convertOptions(option.options) : {};
            else
                convertedOptions[option.name] = 'value' in option && option.value !== undefined ? option.value : {};
        }
        return convertedOptions;
    }
    /** @private */
    static getSubcommandArray(options) {
        const result = [];
        for (const option of options) {
            if ('options' in option || !('value' in option))
                result.push(option.name, ...(option.options ? CommandContext.getSubcommandArray(option.options) : []));
        }
        return result;
    }
}
exports.CommandContext = CommandContext;
exports.Context = CommandContext;
