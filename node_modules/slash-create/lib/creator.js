"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Creator = exports.SlashCreator = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const collection_1 = __importDefault(require("@discordjs/collection"));
const util_1 = require("./util");
const constants_1 = require("./constants");
const command_1 = require("./command");
const requestHandler_1 = require("./util/requestHandler");
const api_1 = require("./api");
const commandContext_1 = require("./structures/interfaces/commandContext");
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const lodash_uniq_1 = __importDefault(require("lodash.uniq"));
const componentContext_1 = require("./structures/interfaces/componentContext");
/** The main class for using commands and interactions. */
class SlashCreator extends eventemitter3_1.default {
    /** @param opts The options for the creator */
    constructor(opts) {
        // eslint-disable-next-line constructor-super
        super();
        /** The API handler for the creator */
        this.api = new api_1.SlashCreatorAPI(this);
        /** The commands loaded onto the creator */
        this.commands = new collection_1.default();
        /** @hidden */
        this._componentCallbacks = new Map();
        if (!opts.applicationID)
            throw new Error('An application ID must be defined!');
        if (opts.token && !opts.token.startsWith('Bot ') && !opts.token.startsWith('Bearer '))
            opts.token = 'Bot ' + opts.token;
        // Define default options
        this.options = Object.assign({
            agent: null,
            allowedMentions: {
                users: true,
                roles: true
            },
            defaultImageFormat: 'jpg',
            defaultImageSize: 128,
            unknownCommandResponse: true,
            handleCommandsManually: false,
            latencyThreshold: 30000,
            ratelimiterOffset: 0,
            requestTimeout: 15000,
            maxSignatureTimestamp: 5000,
            endpointPath: '/interactions',
            serverPort: 8030,
            serverHost: 'localhost'
        }, opts);
        this.allowedMentions = util_1.formatAllowedMentions(this.options.allowedMentions);
        this.requestHandler = new requestHandler_1.RequestHandler(this);
        this.api = new api_1.SlashCreatorAPI(this);
    }
    /**
     * Registers a single command
     * @param command Either a Command instance, or a constructor for one
     * @see SlashCreator#registerCommands
     */
    registerCommand(command) {
        if (typeof command === 'function')
            command = new command(this);
        else if (typeof command.default === 'function')
            command = new command.default(this);
        if (!(command instanceof command_1.SlashCommand))
            throw new Error(`Invalid command object to register: ${command}`);
        // Make sure there aren't any conflicts
        if (this.commands.some((cmd) => cmd.keyName === command.keyName))
            throw new Error(`A command with the name "${command.commandName}" (${command.keyName}) is already registered.`);
        if (command.guildIDs &&
            this.commands.some((cmd) => !!(cmd.type === command.type &&
                cmd.commandName === command.commandName &&
                cmd.guildIDs &&
                cmd.guildIDs.map((gid) => command.guildIDs.includes(gid)).includes(true))))
            throw new Error(`A command with the name "${command.commandName}" has a conflicting guild ID.`);
        if (command.unknown && this.unknownCommand)
            throw new Error('An unknown command is already registered.');
        if (command.unknown)
            this.unknownCommand = command;
        else
            this.commands.set(command.keyName, command);
        this.emit('commandRegister', command, this);
        this.emit('debug', `Registered command ${command.keyName}.`);
        return this;
    }
    /**
     * Registers multiple commands
     * @param commands An array of Command instances or constructors
     * @param ignoreInvalid Whether to skip over invalid objects without throwing an error
     */
    registerCommands(commands, ignoreInvalid = false) {
        if (!Array.isArray(commands))
            throw new TypeError('Commands must be an Array.');
        for (const command of commands) {
            const valid = typeof command === 'function' ||
                typeof command.default === 'function' ||
                command instanceof command_1.SlashCommand ||
                command.default instanceof command_1.SlashCommand;
            if (ignoreInvalid && !valid) {
                this.emit('warn', `Attempting to register an invalid command object: ${command}; skipping.`);
                continue;
            }
            this.registerCommand(command);
        }
        return this;
    }
    /**
     * Registers all commands in a directory. The files must export a Command class constructor or instance.
     * @param options The path to the directory, or a require-all options object
     * @example
     * const path = require('path');
     * creator.registerCommandsIn(path.join(__dirname, 'commands'));
     */
    registerCommandsIn(options) {
        const obj = require('require-all')(options);
        const commands = [];
        function iterate(obj) {
            for (const command of Object.values(obj)) {
                if (typeof command === 'function')
                    commands.push(command);
                else if (typeof command === 'object')
                    iterate(command);
            }
        }
        iterate(obj);
        if (typeof options === 'string' && !this.commandsPath)
            this.commandsPath = options;
        else if (typeof options === 'object' && !this.commandsPath)
            this.commandsPath = options.dirname;
        return this.registerCommands(commands, true);
    }
    /**
     * Reregisters a command. (does not support changing name, or guild IDs)
     * @param command New command
     * @param oldCommand Old command
     */
    reregisterCommand(command, oldCommand) {
        if (typeof command === 'function')
            command = new command(this);
        else if (typeof command.default === 'function')
            command = new command.default(this);
        if (!(command instanceof command_1.SlashCommand))
            throw new Error(`Invalid command object to reregister: ${command}`);
        oldCommand.onUnload();
        if (!command.unknown) {
            if (command.commandName !== oldCommand.commandName)
                throw new Error('Command name cannot change.');
            if (!lodash_isequal_1.default(command.guildIDs, oldCommand.guildIDs))
                throw new Error('Command guild IDs cannot change.');
            this.commands.set(command.keyName, command);
        }
        else if (this.unknownCommand !== oldCommand) {
            throw new Error('An unknown command is already registered.');
        }
        else {
            this.unknownCommand = command;
        }
        this.emit('commandReregister', command, oldCommand);
        this.emit('debug', `Reregistered command ${command.keyName}.`);
    }
    /**
     * Unregisters a command.
     * @param command Command to unregister
     */
    unregisterCommand(command) {
        command.onUnload();
        if (this.unknownCommand === command)
            this.unknownCommand = undefined;
        else
            this.commands.delete(command.keyName);
        this.emit('commandUnregister', command);
        this.emit('debug', `Unregistered command ${command.keyName}.`);
    }
    /**
     * Attaches a server to the creator.
     * @param server The server to use
     */
    withServer(server) {
        if (this.server)
            throw new Error('A server was already set in this creator.');
        this.server = server;
        if (this.server.isWebserver) {
            if (!this.options.publicKey)
                throw new Error('A public key is required to be set when using a webserver.');
            this.server.createEndpoint(this.options.endpointPath, this._onRequest.bind(this));
        }
        else
            this.server.handleInteraction((interaction) => this._onInteraction(interaction, null, false));
        return this;
    }
    /** Starts the server, if one was defined. */
    async startServer() {
        if (!this.server)
            throw new Error('No server was set in this creator.');
        await this.server.listen(this.options.serverPort, this.options.serverHost);
        this.emit('debug', 'Server started');
    }
    /**
     * Sync all commands with Discord. This ensures that commands exist when handling them.
     * <warn>This requires you to have your token set in the creator config.</warn>
     */
    syncCommands(opts) {
        const options = Object.assign({
            deleteCommands: true,
            syncGuilds: true,
            skipGuildErrors: true,
            syncPermissions: true
        }, opts);
        const promise = async () => {
            let guildIDs = [];
            // Collect guild IDs with specific commands
            for (const [, command] of this.commands) {
                if (command.guildIDs)
                    guildIDs = lodash_uniq_1.default([...guildIDs, ...command.guildIDs]);
            }
            await this.syncGlobalCommands(options.deleteCommands);
            // Sync guild commands
            for (const guildID of guildIDs) {
                try {
                    await this.syncCommandsIn(guildID, options.deleteCommands);
                }
                catch (e) {
                    if (options.skipGuildErrors) {
                        this.emit('warn', `An error occurred during guild sync (${guildID}): ${e.message}`);
                    }
                    else {
                        throw e;
                    }
                }
            }
            this.emit('debug', 'Finished syncing commands');
            if (options.syncPermissions)
                try {
                    await this.syncCommandPermissions();
                }
                catch (e) {
                    this.emit('error', e);
                }
        };
        promise()
            .then(() => this.emit('synced'))
            .catch((err) => this.emit('error', err));
        return this;
    }
    /**
     * Sync guild commands.
     * <warn>This requires you to have your token set in the creator config.</warn>
     * @param guildID The guild to sync
     * @param deleteCommands Whether to delete command not found in the creator
     */
    async syncCommandsIn(guildID, deleteCommands = true) {
        const commands = await this.api.getCommands(guildID);
        const handledCommands = [];
        const updatePayload = [];
        for (const applicationCommand of commands) {
            const partialCommand = Object.assign({}, applicationCommand);
            delete partialCommand.application_id;
            delete partialCommand.guild_id;
            delete partialCommand.id;
            delete partialCommand.version;
            const command = this.commands.find((command) => !!(command.guildIDs &&
                command.guildIDs.includes(guildID) &&
                command.commandName === partialCommand.name &&
                command.type === partialCommand.type));
            if (command) {
                command.ids.set(guildID, applicationCommand.id);
                this.emit('debug', `Found guild command "${applicationCommand.name}" (${applicationCommand.id}, type ${applicationCommand.type}, guild: ${guildID})`);
                updatePayload.push({
                    id: applicationCommand.id,
                    ...command.commandJSON
                });
                handledCommands.push(command.keyName);
            }
            else if (deleteCommands) {
                this.emit('debug', `Removing guild command "${applicationCommand.name}" (${applicationCommand.id}, type ${applicationCommand.type}, guild: ${guildID})`);
            }
            else {
                updatePayload.push(applicationCommand);
            }
        }
        const commandsPayload = commands.map((cmd) => {
            delete cmd.application_id;
            delete cmd.guild_id;
            delete cmd.version;
            return cmd;
        });
        const unhandledCommands = this.commands.filter((command) => !!(command.guildIDs && command.guildIDs.includes(guildID) && !handledCommands.includes(command.keyName)));
        for (const [, command] of unhandledCommands) {
            this.emit('debug', `Creating guild command "${command.commandName}" (type ${command.type}, guild: ${guildID})`);
            updatePayload.push({
                ...command.commandJSON
            });
        }
        if (!lodash_isequal_1.default(updatePayload, commandsPayload)) {
            // Set command IDs for permission syncing
            const updatedCommands = await this.api.updateCommands(updatePayload, guildID);
            const newCommands = updatedCommands.filter((newCommand) => !commands.find((command) => command.id === newCommand.id));
            for (const newCommand of newCommands) {
                const command = unhandledCommands.find((command) => command.commandName === newCommand.name);
                if (command)
                    command.ids.set(guildID, newCommand.id);
            }
        }
    }
    /**
     * Sync global commands.
     * <warn>This requires you to have your token set in the creator config.</warn>
     * @param deleteCommands Whether to delete command not found in the creator
     */
    async syncGlobalCommands(deleteCommands = true) {
        const commands = await this.api.getCommands();
        const handledCommands = [];
        const updatePayload = [];
        for (const applicationCommand of commands) {
            const partialCommand = Object.assign({}, applicationCommand);
            const commandKey = `${partialCommand.type || constants_1.ApplicationCommandType.CHAT_INPUT}:global:${partialCommand.name}`;
            delete partialCommand.application_id;
            delete partialCommand.id;
            delete partialCommand.version;
            const command = this.commands.get(commandKey);
            if (command) {
                command.ids.set('global', applicationCommand.id);
                this.emit('debug', `Found command "${applicationCommand.name}" (${applicationCommand.id}, type ${applicationCommand.type})`);
                updatePayload.push({
                    id: applicationCommand.id,
                    ...command.commandJSON
                });
            }
            else if (deleteCommands) {
                this.emit('debug', `Removing command "${applicationCommand.name}" (${applicationCommand.id}, type ${applicationCommand.type})`);
            }
            else {
                updatePayload.push(applicationCommand);
            }
            handledCommands.push(commandKey);
        }
        const commandsPayload = commands.map((cmd) => {
            delete cmd.application_id;
            delete cmd.version;
            return cmd;
        });
        const unhandledCommands = this.commands.filter((command) => !command.guildIDs && !handledCommands.includes(command.keyName));
        for (const [, command] of unhandledCommands) {
            this.emit('debug', `Creating command "${command.commandName}" (type ${command.type})`);
            updatePayload.push({
                ...command.commandJSON
            });
        }
        if (!lodash_isequal_1.default(updatePayload, commandsPayload)) {
            const updatedCommands = await this.api.updateCommands(updatePayload);
            const newCommands = updatedCommands.filter((newCommand) => !commands.find((command) => command.id === newCommand.id));
            for (const newCommand of newCommands) {
                const command = unhandledCommands.find((command) => command.commandName === newCommand.name);
                if (command)
                    command.ids.set('global', newCommand.id);
            }
        }
    }
    /**
     * Sync command permissions.
     * <warn>This requires you to have your token set in the creator config AND have commands already synced previously.</warn>
     */
    async syncCommandPermissions() {
        const guildPayloads = {};
        for (const [, command] of this.commands) {
            if (command.permissions) {
                for (const guildID in command.permissions) {
                    const commandID = command.ids.get(guildID) || command.ids.get('global');
                    if (!commandID)
                        continue;
                    if (!(guildID in guildPayloads))
                        guildPayloads[guildID] = [];
                    guildPayloads[guildID].push({
                        id: commandID,
                        permissions: command.permissions[guildID]
                    });
                }
            }
        }
        for (const guildID in guildPayloads)
            await this.api.bulkUpdateCommandPermissions(guildID, guildPayloads[guildID]);
    }
    /**
     * Updates the command IDs internally in the creator.
     * Use this if you make any changes to commands in the API.
     * @param skipGuildErrors Whether to prevent throwing an error if the API failed to get guild commands
     */
    async collectCommandIDs(skipGuildErrors = true) {
        let guildIDs = [];
        for (const [, command] of this.commands) {
            if (command.guildIDs)
                guildIDs = lodash_uniq_1.default([...guildIDs, ...command.guildIDs]);
        }
        const commands = await this.api.getCommands();
        for (const applicationCommand of commands) {
            const commandKey = `${applicationCommand.type}:global:${applicationCommand.name}`;
            const command = this.commands.get(commandKey);
            if (command)
                command.ids.set('global', applicationCommand.id);
        }
        for (const guildID of guildIDs) {
            try {
                const commands = await this.api.getCommands(guildID);
                for (const applicationCommand of commands) {
                    const command = this.commands.find((command) => !!(command.guildIDs &&
                        command.guildIDs.includes(guildID) &&
                        command.commandName === applicationCommand.name &&
                        command.type === applicationCommand.type));
                    if (command)
                        command.ids.set(guildID, applicationCommand.id);
                }
            }
            catch (e) {
                if (skipGuildErrors) {
                    this.emit('warn', `An error occurred during guild command ID collection (${guildID}): ${e}`);
                }
                else {
                    throw e;
                }
            }
        }
    }
    /**
     * Cleans any awaiting component callbacks from command contexts.
     */
    cleanRegisteredComponents() {
        if (this._componentCallbacks.size)
            for (const [key, callback] of this._componentCallbacks) {
                if (callback.expires < Date.now())
                    this._componentCallbacks.delete(key);
            }
    }
    _getCommandFromInteraction(interaction) {
        return 'guild_id' in interaction
            ? this.commands.find((command) => !!(command.guildIDs &&
                command.guildIDs.includes(interaction.guild_id) &&
                command.commandName === interaction.data.name &&
                command.type === interaction.data.type)) || this.commands.get(`${interaction.data.type}:global:${interaction.data.name}`)
            : this.commands.get(`${interaction.data.type}:global:${interaction.data.name}`);
    }
    async _onRequest(treq, respond) {
        this.emit('debug', 'Got request');
        // Verify request
        const signature = treq.headers['x-signature-ed25519'];
        const timestamp = treq.headers['x-signature-timestamp'];
        // Check if both signature and timestamp exists, and the timestamp isn't past due.
        if (!signature ||
            !timestamp ||
            parseInt(timestamp) < (Date.now() - this.options.maxSignatureTimestamp) / 1000)
            return respond({
                status: 401,
                body: 'Invalid signature'
            });
        const verified = await util_1.verifyKey(JSON.stringify(treq.body), signature, timestamp, this.options.publicKey);
        if (!verified) {
            this.emit('debug', 'A request failed to be verified');
            this.emit('unverifiedRequest', treq);
            return respond({
                status: 401,
                body: 'Invalid signature'
            });
        }
        try {
            await this._onInteraction(treq.body, respond, true);
        }
        catch (e) { }
    }
    async _onInteraction(interaction, respond, webserverMode) {
        this.emit('rawInteraction', interaction);
        if (!respond || !webserverMode)
            respond = this._createGatewayRespond(interaction.id, interaction.token);
        switch (interaction.type) {
            case constants_1.InteractionType.PING: {
                this.emit('debug', 'Ping recieved');
                this.emit('ping', interaction.user);
                return respond({
                    status: 200,
                    body: {
                        type: constants_1.InteractionResponseType.PONG
                    }
                });
            }
            case constants_1.InteractionType.COMMAND: {
                if (this.options.handleCommandsManually) {
                    this.emit('commandInteraction', interaction, respond, webserverMode);
                    return;
                }
                const command = this._getCommandFromInteraction(interaction);
                if (!command) {
                    this.emit('debug', `Unknown command: ${interaction.data.name} (${interaction.data.id}, ${'guild_id' in interaction ? `guild ${interaction.guild_id}` : `user ${interaction.user.id}`})`);
                    if (this.unknownCommand) {
                        const ctx = new commandContext_1.CommandContext(this, interaction, respond, webserverMode, this.unknownCommand.deferEphemeral);
                        return this._runCommand(this.unknownCommand, ctx);
                    }
                    else if (this.options.unknownCommandResponse)
                        return respond({
                            status: 200,
                            body: {
                                type: constants_1.InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                                data: {
                                    content: util_1.oneLine `
                    This command no longer exists.
                    This command should no longer show up in an hour if it has been deleted.
                  `,
                                    flags: constants_1.InteractionResponseFlags.EPHEMERAL
                                }
                            }
                        });
                    else
                        return respond({
                            status: 400
                        });
                }
                else {
                    const ctx = new commandContext_1.CommandContext(this, interaction, respond, webserverMode, command.deferEphemeral);
                    // Ensure the user has permission to use the command
                    const hasPermission = command.hasPermission(ctx);
                    if (!hasPermission || typeof hasPermission === 'string') {
                        const data = { response: typeof hasPermission === 'string' ? hasPermission : undefined };
                        this.emit('commandBlock', command, ctx, 'permission', data);
                        return command.onBlock(ctx, 'permission', data);
                    }
                    // Throttle the command
                    const throttle = command.throttle(ctx.user.id);
                    if (throttle && command.throttling && throttle.usages + 1 > command.throttling.usages) {
                        const remaining = (throttle.start + command.throttling.duration * 1000 - Date.now()) / 1000;
                        const data = { throttle, remaining };
                        this.emit('commandBlock', command, ctx, 'throttling', data);
                        return command.onBlock(ctx, 'throttling', data);
                    }
                    // Run the command
                    if (throttle)
                        throttle.usages++;
                    return this._runCommand(command, ctx);
                }
            }
            case constants_1.InteractionType.MESSAGE_COMPONENT: {
                this.emit('debug', `Component request recieved: ${interaction.data.custom_id}, (msg ${interaction.message.id}, ${'guild_id' in interaction ? `guild ${interaction.guild_id}` : `user ${interaction.user.id}`})`);
                if (this._componentCallbacks.size || this.listenerCount('componentInteraction') > 0) {
                    const ctx = new componentContext_1.ComponentContext(this, interaction, respond);
                    this.emit('componentInteraction', ctx);
                    this.cleanRegisteredComponents();
                    const componentCallbackKey = `${ctx.message.id}-${ctx.customID}`;
                    if (this._componentCallbacks.has(componentCallbackKey))
                        this._componentCallbacks.get(componentCallbackKey).callback(ctx);
                    break;
                }
                else
                    return respond({
                        status: 200,
                        body: {
                            type: constants_1.InteractionResponseType.DEFERRED_UPDATE_MESSAGE
                        }
                    });
            }
            default: {
                // @ts-ignore
                this.emit('debug', `Unknown interaction type recieved: ${interaction.type}`);
                this.emit('unknownInteraction', interaction);
                return respond({
                    status: 400
                });
            }
        }
    }
    async _runCommand(command, ctx) {
        try {
            this.emit('debug', `Running command: ${ctx.data.data.name} (${ctx.data.data.id}, ${'guild_id' in ctx.data ? `guild ${ctx.data.guild_id}` : `user ${ctx.data.user.id}`})`);
            const promise = command.run(ctx);
            this.emit('commandRun', command, promise, ctx);
            const retVal = await promise;
            if (retVal)
                return command.finalize(retVal, ctx);
        }
        catch (err) {
            this.emit('commandError', command, err, ctx);
            try {
                return command.onError(err, ctx);
            }
            catch (secondErr) {
                return this.emit('error', secondErr);
            }
        }
    }
    _createGatewayRespond(interactionID, token) {
        return async (response) => {
            await this.api.interactionCallback(interactionID, token, response.body);
        };
    }
}
exports.SlashCreator = SlashCreator;
exports.Creator = SlashCreator;
